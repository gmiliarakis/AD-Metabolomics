---
title: "Analysis"
output:
  html_document: 
    toc: yes
    toc_depth: 4
    theme: flatly
  pdf_document:
    toc: yes
  html_notebook: 
    toc: yes
    theme: flatly
    toc_depth: 5
    highlight: pygments
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  comment = "", warning = FALSE
)
```

```{r packages, include=FALSE}
require(heatmaply)
require(globaltest)
require(GlobalAncova)
require(purrr)
require(caret)
require(dplyr)
require(e1071)
require(FMradio)
require(pROC)
require(xgboost)
require(rpart)
require(DMwR2)
require(nnet)
require(rags2ridges)
```

## Data Exploration

The (interactive) correlation heatmap reveals very high correlation among TG compounds.

```{r heatmap}
load("data/data.Rdata")
tabX <- df[df$Diagnosis == "Probable AD", 1:230]
C <- round(cor(X), 2)

heatmaply_cor(C, color = viridis, plot_method = "plotly", dendrogram = F, reorderfun = sort.default(d,w), main = "Correlation Heatmap", file = "heatmap.html", colorbar_thickness = 15, colorbar_len = 0.5)
```

## RQi: Differential expression of metabolites per ApoE genotype

### Global test in AD group

Performing a Global Test on the serum metabolites of AD patients, correcting for sex (Ho: E4 status has no effect on metabolite levels, Ha: it has an effect), yields a significant difference (p = 0.046) between E4 carriers and non-carriers. Moreover, a 

```{r, fig.height=8}
load("data/clinical.Rdata")
clinical$V_MMSE <- NULL
df[,1:230] <- scale(df[,1:230])
AD <- subset(df, Diagnosis == "Probable AD")
AD$sex <- as.numeric(AD$sex) -1
# Testing for effects
gt.b <- globaltest::gt(E4 ~ 1, E4 ~ .-E4dose -Diagnosis -target, data = AD)
gt.b
globaltest::covariates(gt.b)
```

```{r gt, fig.height=8}
# Multinomial outcome
AD$E4dose <- as.factor(AD$E4dose)
gt.m <- globaltest::gt(E4dose ~ 1, E4dose ~ .-E4 -Diagnosis -target, data = AD)
gt.m
globaltest::covariates(gt.m)
```

### Hierarchical global ANCOVA testing on generalised linear models, AD and SCD
```{r}
# get a hierarchy for variables
dend <- as.dendrogram(hclust(dist(t(df[,1:230]))))
# hierarchical test for ApoE4 presence and AD
set.seed(555)
hierGA <- gGlobalAncova.hierarchical(df[,1:230], H = dend, formula.full = ~target +sex, model.dat = df, alpha = 0.05, perm = 100)
results(hierGA)
# get names of significant clusters
sigEndnodes(hierGA)
```
### Nested Linear Models
Metabolite-level models to test for ApoE4 dose effects.
```{r}
nested <- function(Y, x, ...) {
  ### Analysis of Variance (ANOVA)
  df <- cbind(Y, as.factor(x), ...)
  ncol <- ncol(Y)
  covariates <- names(...)
  F_tests <- furrr::future_map(df[, 1:ncol], ~ {
    frm <- as.formula(paste0(".x ~", paste(covariates, collapse = "+")))
    rm <- lm(frm, data = df)
    ffm <- as.formula(paste0(".x ~ x +", paste(covariates, collapse = "+")))
    fm <- lm(ffm, data = df)
    anova(rm, fm)
  })
  # Correction for Multiple Testing
  # Create a list to store the p-values
  p_values <- list(1:ncol)
  # Extract the p-values of the F-tests from the anova summaries list and store them in p_values
  for (i in 1:ncol) {
    p_values[[i]] <- F_tests[[i]][["Pr(>F)"]][[2]]
  }
  # Coerce p_values to dataframe and transpose it
  p_values <- t(data.frame(p_values))

  # Set as row names the metabolites
  p_values <- data.frame(p_values, row.names = colnames(Y))

  # Calculate the FDR-adjusted p-values
  p_values$p_adj <- p.adjust(p_values[, ], method = "fdr")
  
  # Filter out the non-significant (a=0.05) FDR-adjusted p-values
  sig <- dplyr::filter(p_values, p_values < 0.05)

  t_tests <- furrr::future_map(df[, rownames(sig)], ~ {
    f <- as.formula(paste0(".x ~ x +", paste(covariates, collapse = "+")))
    mdl <- lm(f, data = df)
    summary(mdl)$coefficients[1:length(table(x)), ]
  })
  out <- list("Sig. F tests"=sig[order(sig$p_adj),], "Coefficients" = t_tests)
  return(out)
}
```
#### Testing in both SCD and AD
```{r}
#Testing in all samples
Y <- df[, 1:230]
clinical$V_MMSE <- NULL
target <- df$target

## Testing for effects of presence of ApoE4 in combination with AD diagnosis
nested.all <- nested(Y, target, clinical)

## Testing for effects of ApoE4 dose
df$E4dose <- as.numeric(df$E4dose)-1
df$E4dose[df$E4dose == 0] <- "0ApoE4"
df$E4dose[df$E4dose == 1] <- "1ApoE4"
df$E4dose[df$E4dose == 2] <- "2ApoE4"
E4dose <- df$E4dose <- as.factor(df$E4dose)
nested(Y, E4dose, clinical)[[1]]
nested(Y, E4dose, clinical)[[2]]
```

#### Testing for ApoE4 dose effects in AD group only
```{r}
ADY <- AD[, 1:230]
ADE4dose <- AD$E4dose
ADclinical <- clinical[df$Diagnosis == "Probable AD",]

##Testing for effects of ApoE4 dose
nested(ADY, ADE4dose, ADclinical)
```

#### Testing for ApoE4 dose effects in SCD group only
```{r}
SCD <- df[df$Diagnosis == "Subjectieve klachten",]
SCDY <- SCD[, 1:230]
SCDE4dose <- SCD$E4dose
SCDclinical <- clinical[df$Diagnosis == "Subjectieve klachten",]

## Testing for effects of ApoE4 dose
nested(SCDY, SCDE4dose, SCDclinical)
```

## RQii - Classification of metabolites on ApoE class
### Multinomial Classification of number of ApoE E4 alleles based on metabolites

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  comment = NA, warning = FALSE
)
```
```{r multifit}
multifit <- function(
                X,
                y,
                model,
                ctrl = NULL,
                grid = NULL,
                seed = 87654, ...) {
  set.seed(seed)
  # Merge X and y into df
  df <- cbind.data.frame(X, y)
  # Train the model
  mdl <- caret::train(df[, 1:ncol(X)], df$y,
    method = model,
    tuneGrid = grid,
    trControl = ctrl,
    metric = "logLoss",
    ...
  )
  # Create a confusion matrix and get performance metrics from caret
  obs <- mdl$pred$obs
  preds <- mdl$pred$pred
  cm <- confusionMatrix(reference = obs, data = preds, mode = "everything")
  # Get the multiclass AUC
  ys <- as.numeric(obs) -1
  yhats <- as.numeric(preds) -1
  roc <- multiclass.roc(response = ys, predictor = yhats, quiet = T)
  out <- list("cm" = cm, "roc" = roc, "model" = mdl)
  return(out)
}
```

### Preparation
```{r multi_preparation}
load("data/data.Rdata")
X <- scale(df[, 1:230])
y <- df$target

Xclin = cbind.data.frame(X, clin_dummy)


ctrl <- trainControl(
  method = "repeatedcv",
  number = 10,
  repeats = 100,
  savePredictions = "final",
  classProbs = T,
  summaryFunction = multiClassSummary,
  selectionFunction = best,
  search = "random",
  sampling = "smote"
)
```

### Fitting a benchmark model: clinical characteristics only

```{r mlogit}
bm <- multifit(
  X = clin_dummy,
  y = y,
  model = "multinom",
  ctrl = ctrl,
  grid = expand.grid(decay = 0),
  trace = F
)
bm$cm
bm$roc
ggroc(bm$roc$rocs)
```

### Regularized Multinomial Regression adding 230 metabolites

```{r}
mlr <- multifit(
  X = Xclin,
  y = y,
  model = "multinom",
  ctrl = ctrl,
  grid = expand.grid(decay = 10),
  trace = F
)
mlr$cm
mlr$roc
ggroc(mlr$roc$rocs)
```

### Projection to Latent Factors

```{r get_thomson}
project <- function(X, m, seed) {
  set.seed(seed)
  X <- scale(as.matrix(df[,1:230]))
  cov <- cor(X)

  # Find redundant features
  filter <- RF(cov)

  # Filter out redundant features
  filtered <- subSet(X, filter)

  # Regularized correlation matrix estimation
  M <- regcor(filtered)

  # Get the regularized correlation matrix of the filtered dataset
  R <- M$optCor

  mlfa <- mlFA(R, m = 6)
  thomson <- facScore(filtered, mlfa$Loadings, mlfa$Uniqueness)
  return(thomson)
}
```

```{r}
thomson <- project(X, 6, seed = 1234)
X <- cbind(clin_dummy, thomson)
```

#### Multinomial Logistic Regression adding 6 factors
```{r }
mlrf <- multifit(
  X = X,
  y = y,
  model = "multinom",
  ctrl = ctrl,
  trace = FALSE,
  grid = expand.grid(decay = 0)
)
mlrf$cm
mlrf$roc
ggroc(mlrf$roc$rocs)
```

#### Decision Tree

```{r multi_tree}
tree <- multifit(
  X = X,
  y = y,
  model = "rpart2",
  ctrl = ctrl,
  grid = expand.grid(maxdepth=3)
)
tree$cm
tree$roc
ggroc(tree$roc$rocs)
```

#### XGBoost Forest

```{r }
xgb <- multifit(
  X = X,
  y = y,
  model = "xgbTree",
  ctrl = ctrl,
  grid = xgb.grid
)
xgb$cm
xgb$roc
ggroc(xgb$roc$rocs)
```
###


1. Adding serum metabolite information (either the full 230-metabolite matrix or its 6-factor projection) seems to increase the discriminatory power of the models.  


2. Fitting 6 ML-estimated factors obtained by the FMradio package (cummulatively explaining 30% of variace) yields increased classification performance, serving as a valuable dimension reduction technique for high-dimensional data.


3. Looking at the confusion matrix and individual ROC curves, all models were able to discriminate better among certain classes (AD+E4/SCD+E4, AD+E4/SCD+E4, AD-E4/SCD+E4 and AD-E4/SCD-E4) compared to others (AD+E4/SCD-E4 and SCD+E4/SCD-E4).

```{r}
aucs <- c(MLR0 = bm$roc$auc, MLR1 = mlr$roc$auc, MLR2 = mlrf$roc$auc, TREE = tree$roc$auc, XGB = xgb$roc$auc)
knitr::kable(t(aucs))
```

## RQiii - Network Analysis

```{r preparation}
# Store all observations of Class 1 in C1
C1 <- scale(df[df$APOE == "E4NO",1:230])
# Store all observations of Class 2 in C2
C2 <- scale(df[APOE == "E4YES",1:230])

# Get the covariance matrices of C1 and C2
S1 <- covML(C1)
S2 <- covML(C2)

# Store them in a list
S <- list(S1 = S1, S2 = S2)

# Get the total number of samples
n <- c(nrow(S1), nrow(S2))

# Create a list of fused covariance matrices T
Ts <- default.target.fused(Slist = S, ns = n, type = "DUPV")
```

```{r, eval=FALSE}
# Get the optimal lambdas per class and fused with 10-fold CV
set.seed(8910)
optf <- optPenalty.fused(
  Ylist = Ys,
  Tlist = Ts,
  lambda = default.penalty(Ys),
  cv.method = "kCV",
  k = 10,
  verbose = FALSE
)
save(optf, file= "data/optf.Rdata")
```

```{r sparsify, echo = FALSE}
# Create a list of the two-class data Y
load("data/optf.Rdata")
Ys <- list(C0 = C0, C1 = C1)
Ps <- optf$Plist

Ps <- ridgeP.fused(S, n, Ts,lambda = optf$lambda, maxit = 1000)

# Get the sparsified high precision matrices, correcting FDR at .001
P0s <- sparsify.fused(Ps,
  threshold = "localFDR",
  FDRcut = 0.999
)
```

```{r GGMs per class and diff, message=FALSE, echo = FALSE}
# Merge the sparse high precision matrices
TST <- Union(P0s$S0$sparseParCor, P0s$S1$sparseParCor)
PCE4NO <- TST$M1subset
PCE4YES <- TST$M2subset

# Create a color map per metabolite class
Colors <- rownames(PCE4YES)
Colors[grep("Amine", rownames(PCE4YES))] <- "#e0ade6"
Colors[grep("Org.Acid", rownames(PCE4YES))] <- "lightblue"
Colors[grep("Lip", rownames(PCE4YES))] <- "yellow"
Colors[grep("Ox.Stress", rownames(PCE4YES))] <- "purple"


set.seed(111213)
opar <- par(mfrow = c(1, 3))
# Plot the sparsified ridge matrix of ApoE4 carriers with AD
Coords <- Ugraph(PCE4YES,
  type = "fancy", lay = "layout_with_fr",
  Vcolor = Colors, prune = FALSE, Vsize = 7, Vcex = 0.3,
  main = "ApoE4 carriers with AD"
)
# Plot he sparsified ridge matrix of ApoE4 non-carriers with AD
Ugraph(PCE4NO,
  type = "fancy", lay = "layout_with_fr",
  Vcolor = Colors, prune = FALSE, Vsize = 7, Vcex = 0.3,
  main = "ApoE4 non-carriers with AD"
)

# Plot the differential network
DiffGraph(PCE4NO, PCE4YES,
  lay = "layout_with_fr",
  Vcolor = Colors, Vsize = 7, Vcex = 0.3,
  main = "Differential Network"
)
par(opar)
```

```{r centrality}
PC0list <- list(PCE4NO = PCE4NO, PCE4YES = PCE4YES)
# Get the network statistics
NetStats <- GGMnetworkStats.fused(PC0list)

NetStatsE4yes <- NetStats[,10:18]
NetStatsE4no <- NetStats[, 1:9]

NetStatsE4yes[, c(3, 9)] <- NetStatsE4no[, c(3, 9)] <- NULL
```

```{r degree density plot }
# Plot the densities of centrality degree scores
plot(density(DegreesAD1[, 2]),
  col = "blue", xlim = c(-1, 8), xlab = "Degree", main = ""
)
lines(density(DegreesAD2[, 2]),
  col = "red"
)
legenda <- c("AD class 1", "AD class 2")
legend(5, 0.5,
  legend = legenda, 
  lwd = rep(1, 2), lty = rep(1, 2), col = c("blue", "red"), cex = 0.7
)
```

```{r wilcoxon rank sum }
# Perform a Wilcoxon signed rank test

w <- furrr::future_map2(NetStatsE4yes[, 1:7], NetStatsE4no[, 1:7], ~ {
  wilcox.test(.x, .y, paired = TRUE, alternative = "greater")
})
p.values <- list(1:length(w))
for(i in 1:length(w)){
  p.values[i] <- w[[i]][['p.value']]
}
names(p.values) <- names(w)
dplyr::filter(p.values, p.values<0.05)
```
```{r communities}
# Get the communities per class
set.seed(141516)
opar <- par(mfrow = c(1, 2))
CommC1 <- Communities(PCE4NO,
  Vcolor = Colors,
  Vsize = 7, Vcex = 0.3, main = "Modules AD Class 1"
)

CommC2 <- Communities(PCE4YES,
  Vcolor = Colors,
  Vsize = 7, Vcex = 0.3, main = "Modules AD Class 2"
)
par(opar)
```